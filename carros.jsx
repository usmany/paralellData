#target illustrator#includepath .#include readProcessCsv.jsx#include mayorMenor.jsx#include linearScale.jsxvar dataCars = File.openDialog("Selecciona archivo de datos de carros", ".csv", false);var dataCars = leeProcesa(dataCars);var width = 1000 ;var height = 500;var doc = app.documents.add(null, width, height);var axesItems = doc.pathItems;var lineas = doc.pathItems;var dimNames = doc.textFrames;var textMinimos = doc.textFrames;var textMaximos = doc.textFrames;var min;var max;//colores para las lineasvar brushed = new CMYKColor();brushed.cyan = 60;brushed.magenta = 10;brushed.yellow = 0;brushed.black = 0;var noBrushed = new CMYKColor();noBrushed.cyan = 0;noBrushed.magenta = 0;noBrushed.yellow = 0;noBrushed.black = 25; function creaAxis(arr) {		var iniciox = 0;		var axItem = [];		var dimName = [];	var textMinimo = [];	var textMaximo = [];		var dimensiones = arr.split('\t');	var numDimensiones = dimensiones.length;	var d = 1;			for (; d < numDimensiones; d = d + 1) {		//alert(dimensiones[d]);		axItem[d] = axesItems.add();		axItem[d] .setEntirePath ([			[iniciox, 0],			[iniciox, height]		]);				axItem[d].name = dimensiones[d];				dimName[d] = dimNames.add();		dimName[d] = dimNames.pointText ( [iniciox, (height+25)] );		dimName[d].contents = dimensiones[d];		textMinimo[d] = textMinimos.add();		textMinimo[d] = textMinimos.pointText ( [iniciox, -15] );		textMinimo[d].contents = min[d-1];				textMaximo[d] = textMaximos.add();		textMaximo[d] = textMaximos.pointText ( [iniciox, (height+7)] );		textMaximo[d].contents = max[d-1];				iniciox = iniciox + (width / (numDimensiones-2));			}}function maximos (arr) {		var totalLineas = arr.length;			var datos = [];	var max;	var dimensiones = arr[0].split('\t');	var numDimensiones = dimensiones.length;			for (var i = 1; i < numDimensiones; i++) { 	// var i = 1; para evitar usar 1ra. fila de nombres de las columnas			max = 0;			for (var j = 1; j < totalLineas; j++) { // var j = 1; para evitar usar el nombre del archivo				if (max < Number(arr[j].split('\t')[i])) {										max = Number(arr[j].split('\t')[i]);				}			}		datos.push(max);	} return datos;}function minimos (arr) {		var totalLineas = arr.length;			var datos = [];	var min;	var dimensiones = arr[0].split('\t');	var numDimensiones = dimensiones.length;			for (var i = 1; i < numDimensiones; i++) { 	// var i = 1; para evitar usar 1ra. fila de nombres de las columnas			min = 100000000000; // an arbitrary high value to start comparitions			for (var j = 1; j < totalLineas; j++) { // var j = 1; para evitar usar el nombre del archivo				//alert (Number(arr[j].split('\t')[i]));				if (min > Number(arr[j].split('\t')[i])) {										min = Number(arr[j].split('\t')[i]);				}			}		datos.push(min);	} return datos;}min = minimos(dataCars);max = maximos (dataCars);creaAxis(dataCars[0]);/* 	Generating the actual chart:	I didn't put this into a function because right now I have no idea of how to make this	enterely out of pure code:	I don't know how to make a continuos line programmatically	I think that it maybe can be solved by concatenating a string and	then evaluate it inside linea[i].setEntirePath(--concatenated string of values--);	But I am busy with other things right now.*/var totalLineas = dataCars.length;	var dimensiones = dataCars[0].split('\t');var linea = [];		for (var i = 1; i < totalLineas; i++) {			linea[i] = lineas.add();						linea[i].setEntirePath([			[axesItems[dimensiones[1]].pathPoints[0].anchor[0], scaleLinear(0, height, min[0], max[0], dataCars[i].split('\t')[1])],			[axesItems[dimensiones[2]].pathPoints[0].anchor[0], scaleLinear(0, height, min[1], max[1], dataCars[i].split('\t')[2])],			[axesItems[dimensiones[3]].pathPoints[0].anchor[0], scaleLinear(0, height, min[2], max[2], dataCars[i].split('\t')[3])],			[axesItems[dimensiones[4]].pathPoints[0].anchor[0], scaleLinear(0, height, min[3], max[3], dataCars[i].split('\t')[4])],			[axesItems[dimensiones[5]].pathPoints[0].anchor[0], scaleLinear(0, height, min[4], max[4], dataCars[i].split('\t')[5])],			[axesItems[dimensiones[6]].pathPoints[0].anchor[0], scaleLinear(0, height, min[5], max[5], dataCars[i].split('\t')[6])],			[axesItems[dimensiones[7]].pathPoints[0].anchor[0], scaleLinear(0, height, min[6], max[6], dataCars[i].split('\t')[7])],					]);			linea[i].filled = false;			linea[i].name = dataCars[i].split('\t')[0];									//trying brussing some records			if (dataCars[i].split('\t')[2] == 4 && dataCars[i].split('\t')[7] > 80) {				linea[i].strokeColor = brushed;				linea[i].zOrder(ZOrderMethod.BRINGTOFRONT);							} else {				linea[i].strokeColor = noBrushed;				linea[i].zOrder(ZOrderMethod.SENDTOBACK);			}}app.redraw();